name: Suggest Version

on:
  workflow_dispatch:
    inputs:
      pre_release_version:
        description: 'Pre-release version to analyze (e.g., v0.0.0-pre.123+abc1234)'
        required: true
        type: string

jobs:
  analyze-and-suggest:
    name: Analyze Changes and Suggest Version
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Checkout pre-release commit
        run: |
          PRE_VERSION="${{ inputs.pre_release_version }}"
          PRE_SHA=$(git rev-parse "$PRE_VERSION")
          git checkout "$PRE_SHA"
          echo "Checked out commit: $PRE_SHA"

      - name: Get current version
        id: current
        run: |
          # Find latest full release (not pre-release)
          LATEST_RELEASE=$(git tag -l "v[0-9]*.[0-9]*.[0-9]*" | sort -V | tail -1)
          if [ -z "$LATEST_RELEASE" ]; then
            LATEST_RELEASE="v0.0.0"
          fi

          echo "latest=$LATEST_RELEASE" >> $GITHUB_OUTPUT
          echo "ðŸ“Œ Latest release: $LATEST_RELEASE"

          # Parse version components
          VERSION=${LATEST_RELEASE#v}
          MAJOR=$(echo "$VERSION" | cut -d. -f1)
          MINOR=$(echo "$VERSION" | cut -d. -f2)
          PATCH=$(echo "$VERSION" | cut -d. -f3)

          echo "major=$MAJOR" >> $GITHUB_OUTPUT
          echo "minor=$MINOR" >> $GITHUB_OUTPUT
          echo "patch=$PATCH" >> $GITHUB_OUTPUT

      - name: Analyze changes since last release
        id: analyze
        run: |
          LATEST="${{ steps.current.outputs.latest }}"
          PRE_VERSION="${{ inputs.pre_release_version }}"

          echo "ðŸ” Analyzing changes from $LATEST to $PRE_VERSION..."
          echo ""

          # Get changed files
          CHANGED_FILES=$(git diff --name-only $LATEST..HEAD 2>/dev/null || echo "")

          # Initialize flags
          BREAKING_CHANGE=false
          SCHEMA_CHANGED=false
          CODE_CHANGED=false
          CONFIG_ONLY=false

          # Check commit messages for breaking changes
          COMMITS=$(git log $LATEST..HEAD --pretty=format:"%s %b")
          if echo "$COMMITS" | grep -qiE '(BREAKING CHANGE|^feat!:|^fix!:)'; then
            BREAKING_CHANGE=true
            echo "âš ï¸  BREAKING CHANGES in commits:"
            echo "$COMMITS" | grep -iE '(BREAKING CHANGE|^feat!:|^fix!:)'
            echo ""
          fi

          # Check schema changes
          if echo "$CHANGED_FILES" | grep -q '^schemas/'; then
            SCHEMA_CHANGED=true
            echo "âœ“ Schema files changed:"
            echo "$CHANGED_FILES" | grep '^schemas/'
            echo ""

            # Detailed schema analysis
            SCHEMA_DIFF=$(git diff $LATEST..HEAD -- schemas/)

            # Check for breaking schema changes
            if echo "$SCHEMA_DIFF" | grep -qE '^\-.*properties:|^\-.*x-generate-field:|^\-.*enum:'; then
              BREAKING_CHANGE=true
              echo "âš ï¸  Breaking schema changes detected:"
              echo "$SCHEMA_DIFF" | grep -E '^\-.*properties:|^\-.*x-generate-field:|^\-.*enum:' | head -10
              echo ""
            fi

            # Check for new fields (non-breaking)
            if echo "$SCHEMA_DIFF" | grep -qE '^\+.*properties:|^\+.*x-generate-field:'; then
              echo "âœ“ New fields added (non-breaking):"
              echo "$SCHEMA_DIFF" | grep -E '^\+.*properties:|^\+.*x-generate-field:' | head -10
              echo ""
            fi
          fi

          # Check code changes
          if echo "$CHANGED_FILES" | grep -qE '^apps/.*\.(go|mod|sum)$'; then
            CODE_CHANGED=true
            echo "âœ“ Code files changed:"
            echo "$CHANGED_FILES" | grep -E '^apps/.*\.(go|mod|sum)$'
            echo ""
          fi

          # Check config-only changes
          if echo "$CHANGED_FILES" | grep -q '^config/' && ! echo "$CHANGED_FILES" | grep -qE '^(schemas/|apps/)'; then
            CONFIG_ONLY=true
            echo "âœ“ Config-only changes (no code/schema changes)"
            echo ""
          fi

          # Determine required bump
          REQUIRED_BUMP="PATCH"
          REASON="Config or documentation changes only"

          if [ "$BREAKING_CHANGE" = "true" ]; then
            REQUIRED_BUMP="MAJOR"
            REASON="Breaking changes detected (schema modifications or BREAKING CHANGE commits)"
          elif [ "$SCHEMA_CHANGED" = "true" ] || [ "$CODE_CHANGED" = "true" ]; then
            REQUIRED_BUMP="MINOR"
            if [ "$SCHEMA_CHANGED" = "true" ] && [ "$CODE_CHANGED" = "true" ]; then
              REASON="Schema and code changes (new features)"
            elif [ "$SCHEMA_CHANGED" = "true" ]; then
              REASON="Schema changes (new fields/types)"
            else
              REASON="Code changes (new features or refactoring)"
            fi
          elif [ "$CONFIG_ONLY" = "true" ]; then
            REQUIRED_BUMP="PATCH"
            REASON="Config-only changes (no recompile needed)"
          fi

          echo "required_bump=$REQUIRED_BUMP" >> $GITHUB_OUTPUT
          echo "reason=$REASON" >> $GITHUB_OUTPUT

          echo "ðŸ“Š Required version bump: $REQUIRED_BUMP"
          echo "ðŸ’¡ Reason: $REASON"
          echo ""

      - name: Calculate suggested versions
        id: suggest
        run: |
          MAJOR=${{ steps.current.outputs.major }}
          MINOR=${{ steps.current.outputs.minor }}
          PATCH=${{ steps.current.outputs.patch }}
          REQUIRED="${{ steps.analyze.outputs.required_bump }}"

          # Calculate all possible next versions
          NEXT_MAJOR="v$((MAJOR + 1)).0.0"
          NEXT_MINOR="v${MAJOR}.$((MINOR + 1)).0"
          NEXT_PATCH="v${MAJOR}.${MINOR}.$((PATCH + 1))"

          echo "next_major=$NEXT_MAJOR" >> $GITHUB_OUTPUT
          echo "next_minor=$NEXT_MINOR" >> $GITHUB_OUTPUT
          echo "next_patch=$NEXT_PATCH" >> $GITHUB_OUTPUT

          # Recommend based on analysis
          case "$REQUIRED" in
            MAJOR)
              RECOMMENDED="$NEXT_MAJOR"
              ;;
            MINOR)
              RECOMMENDED="$NEXT_MINOR"
              ;;
            PATCH)
              RECOMMENDED="$NEXT_PATCH"
              ;;
          esac

          echo "recommended=$RECOMMENDED" >> $GITHUB_OUTPUT

          echo "ðŸ“ Version suggestions:"
          echo "  PATCH (bug fixes, config): $NEXT_PATCH"
          echo "  MINOR (new features):      $NEXT_MINOR"
          echo "  MAJOR (breaking changes):  $NEXT_MAJOR"
          echo ""
          echo "âœ¨ Recommended for this release: $RECOMMENDED"
          echo "   (Based on: ${{ steps.analyze.outputs.reason }})"

      - name: Generate detailed change report
        id: report
        run: |
          LATEST="${{ steps.current.outputs.latest }}"
          RECOMMENDED="${{ steps.suggest.outputs.recommended }}"

          cat > change-report.md << 'EOF'
          # Version Recommendation Report

          ## Current Status
          - **Latest Release**: `${{ steps.current.outputs.latest }}`
          - **Pre-release**: `${{ inputs.pre_release_version }}`
          - **Commits**: $(git rev-list $LATEST..HEAD --count)

          ## Recommended Version: `$RECOMMENDED`

          **Reason**: ${{ steps.analyze.outputs.reason }}

          **Required Bump Type**: ${{ steps.analyze.outputs.required_bump }}

          ## Alternative Versions

          | Bump Type | Version | Use When |
          |-----------|---------|----------|
          | PATCH | `${{ steps.suggest.outputs.next_patch }}` | Bug fixes, config changes only |
          | MINOR | `${{ steps.suggest.outputs.next_minor }}` | New features, schema additions (backward compatible) |
          | MAJOR | `${{ steps.suggest.outputs.next_major }}` | Breaking changes, schema modifications |

          ## Detailed Changes

          ### Commits Since Last Release

          ```
          $(git log $LATEST..HEAD --pretty=format:"- %s (%h by %an)")
          ```

          ### Files Changed

          ```
          $(git diff --stat $LATEST..HEAD)
          ```

          ## Validation Checklist

          Before promoting to release:

          - [ ] All tests pass on pre-release
          - [ ] Deployed to test environment successfully
          - [ ] QA validation complete
          - [ ] CHANGELOG.md updated
          - [ ] Release notes drafted
          - [ ] Version bump matches changes (${{ steps.analyze.outputs.required_bump }})

          ## Next Steps

          1. Review this analysis
          2. Run promote workflow with recommended version:
             ```
             Workflow: Promote to Release
             Inputs:
               pre_release_version: ${{ inputs.pre_release_version }}
               release_version: $RECOMMENDED
               is_rollback: false
             ```
          3. Or choose a different version if needed (see alternatives above)

          ## Guardrails

          âš ï¸ **If you choose a different version**:
          - PATCH when MINOR/MAJOR required â†’ CI will warn
          - MINOR when MAJOR required â†’ CI will fail (breaking changes must be MAJOR)
          - Version already exists â†’ CI will fail

          EOF

          cat change-report.md

      - name: Create workflow suggestion comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const report = fs.readFileSync('change-report.md', 'utf8');

            // Post as comment on the latest PR or commit
            const commit = '${{ github.sha }}';

            core.summary.addRaw(report).write();

      - name: Summary output
        run: |
          echo "## ðŸ“‹ Version Suggestion Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Pre-release:** \`${{ inputs.pre_release_version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "**Latest release:** \`${{ steps.current.outputs.latest }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### âœ¨ Recommended Version" >> $GITHUB_STEP_SUMMARY
          echo "**\`${{ steps.suggest.outputs.recommended }}\`**" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Bump type:** ${{ steps.analyze.outputs.required_bump }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Reason:** ${{ steps.analyze.outputs.reason }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Alternatives" >> $GITHUB_STEP_SUMMARY
          echo "- PATCH: \`${{ steps.suggest.outputs.next_patch }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- MINOR: \`${{ steps.suggest.outputs.next_minor }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- MAJOR: \`${{ steps.suggest.outputs.next_major }}\`" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### Next Action" >> $GITHUB_STEP_SUMMARY
          echo "Run **Promote to Release** workflow with:" >> $GITHUB_STEP_SUMMARY
          echo "- **pre_release_version:** \`${{ inputs.pre_release_version }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **release_version:** \`${{ steps.suggest.outputs.recommended }}\`" >> $GITHUB_STEP_SUMMARY
